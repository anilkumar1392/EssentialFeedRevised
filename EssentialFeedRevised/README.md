###lecture 4.

Testing the mapping in integration
While implementing the success path of the Load Feed Use Case (the happy path delivering an array of mapped FeedItems) we had many options, but we were between testing the mapping of FeedItems using a stubbed collaborator (e.g., a FeedItemDecoder protocol/FeedItemDecoderStub as we did in with the HTTPClient/HTTPClientSpy), or testing the mapping behavior only through the RemoteFeedLoader public APIs (hiding the knowledge of a collaborator from the tests so we don’t need to mock it or explicitly pass an instance). 

In the first option, we could have created a protocol (contract) and a test implementation with the mocked/stubbed collaborator’s response according to our test needs/specifications. “When the RemoteFeedLoader receives data A, then it should ask the collaborator to map data A into [FeedItem]s and complete/return with the collaborator’s mapped items result” (notice how we would be explicitly testing the collaboration of the components rather than the real JSON mapping since there’s no knowledge of JSON or the backend payload contract in this specification). Then, in isolation, we would have to implement and test the real collaborator (where the knowledge of JSON and the backend payload contract would reside). The trade-off (and a common complaint about this approach) is that since we would not be using the real collaborator, we may not be sure they work appropriately when put together (but we could solve that with an integration test).

Instead, we chose to test the mapping of Data -> [FeedItem] and the appropriate mapping error’s only through the RemoteFeedLoader public APIs, or in other words in integration (and also hiding the mapping dependencies). By doing so, we reduced the complexity of our code and object graph (no need for another protocol and test/production implementations), and we’re free to change the mapping implementation without breaking the tests. The tests become as simple as “given this input, we expect this output” (without knowledge of how it’s done internally). 

This is not to say that testing the mapping in integration with the RemoteFeedLoader is a superior solution. Both solutions have their merits and tradeoffs, as by testing the mapping in integration (as we chose) we risk making debugging more time costly as it might be harder to detect exactly where the mistake was made. We believe it’s a fair trade-off and we’re happy with the result for this specific feature. However, we’ll keep an eye on it and, if it ever becomes a problem, we will refactor it into isolated tests.

###lecture 5.
Automating Memory Leak Detection + Preventing a (Way Too Common) Async Bug
