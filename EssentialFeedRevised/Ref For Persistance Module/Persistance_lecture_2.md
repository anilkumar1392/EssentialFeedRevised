
The ever-evolving requirements
Working effectively with ever-evolving requirements is a big part of being a proficient software developer. Incomplete information can easily lead in making wrongful assumptions. The problem is: we often have to work with incomplete information. If we try to solve the wrongful assumption’s problem by coming up with all the requirements upfront, we might end up with analysis-paralysis which can even be a worse state to be in. Software projects, especially large scale, are rarely correctly defined and built on the first try.

A battle-tested solution to too-many-upfront decisions is to iteratively take small steps, learn, and adapt quickly and cost-effectively. By making small incremental steps, we can keep progressing, learn by gathering fast feedback and improve continually. Refining parts of the requirements including scenarios, use cases, flow charts, diagrams are a relatively cost-efficient process with potentially big rewards. Frequent iterations and refinement of the specs allow us to map the project's big picture while focusing on specific isolated parts. For example, as we did with the Networking specs. We don’t need perfect scenarios or use cases up front. Instead, we help the business come up with concise requirements for an initial implementation to swiftly explore solutions through short iterations providing rapid and meaningful feedback. By doing so, we consistently improve the system and the requirements while delivering max value to the business and our customers.

Developing software is a social activity, and often we must gather domain information from people outside the tech team. Sometimes such decisions are not business related, and we can use our expertise as developers to decide reasonable rules. Regardless if they are technical or business decisions we must gather adequate information about the requirements before start coding. Functional teams strive to refine and share domain knowledge at every opportunity.

“Good programmers will naturally start to abstract and develop a model that can do more work. But when this happens only in a technical setting, without collaboration with domain experts, the concepts are naive. That shallowness of knowledge produces software that does a basic job but lacks a deep connection to the domain expert's way of thinking [...] The constant refinement of the domain model forces the developers to learn the important principles of the business they are assisting, rather than to produce functions mechanically ... These models are never perfect; they evolve." – Eric Evans. “Domain-Driven Design”

Decisions are rarely final. To be able to adapt quickly and welcome requirement changes, aim for flexible solutions. Such an approach requires a decoupled/modular structure to keep productivity high and the probability of systemic failure low.
